#!/usr/bin/env python3

import sys
import re
import collections

infilename='sample-input'
if len(sys.argv)>1:
    infilename = sys.argv[1]

with open(infilename, 'r') as f:
    lines = f.readlines()

RE_LINE = re.compile(r'(?P<direc>[UDLR]) (?P<length>\d+) \(#(?P<rgb>[a-f0-9]{6})\)')

Trench = collections.namedtuple('Trench', 'direc length rgb')
trenches = []

MAP_SIZE=(3000,5000)

#digmap = [([['.',[].copy()].copy()]*MAP_SIZE[0]).copy() for _ in range(MAP_SIZE[1])]

digmap = []
for yy in range(MAP_SIZE[1]):
    digmap.append([])
    for xx in range(MAP_SIZE[0]):
        tiledata = ['.', []]
        digmap[-1].append(tiledata)

DIRMAP = {
    'U' : (0,-1),
    'D' : (0, 1),
    'L' : (-1,0),
    'R' : ( 1,0),
}

point = [500, 500]
max_point = point.copy()
min_point = point.copy()
for line in lines:
    mat = RE_LINE.match(line)
    if mat:
        delta = int(mat['length'])
        full_len = delta + 1
        t = Trench(DIRMAP[mat['direc']], full_len, mat['rgb'])

        trenches.append(t)

        for ii in range(delta):
            x, y = point
            assert(x > 0 and y > 0)
            digmap[y][x][0] = '#'
            digmap[y][x][1].append(t)
            x += t.direc[0]
            y += t.direc[1]
            point = (x, y)

        max_point = [ max(p,m) for p,m in zip(point, max_point) ]
        min_point = [ min(p,m) for p,m in zip(point, min_point) ]

        digmap[y][x][0] = '#'
        digmap[y][x][1].append(t)

def print_map():
    assert all(len(row) == len(digmap[0]) for row in digmap)

    for yy in range(len(digmap)):
        print(yy, end='\t')
        for xx in range(len(digmap[0])):
            print(digmap[yy][xx][0],end='')
        print()
    print()

def find_volume():
    volcount = 0

    for yy in range(len(digmap)):
        in_not_out = False
        past_char = '.'

        for xx in range(len(digmap[0])):
            tiledata = digmap[yy][xx]
            trlist = tiledata[1]

            volcount += 1 if in_not_out or tiledata[0] == '#' else 0
            #print('#' if in_not_out else '.', end='')

            is_enter = len([None for tr in trlist if tr.direc[1]==-1]) > 0
            is_exit  = len([None for tr in trlist if tr.direc[1]==1]) > 0

            if is_enter:
                #print('1', end='')
                pass
            elif is_exit:
                assert not is_enter
                #print('2', end='')
            else:
                pass
                #print('0', end='')
            #print(' ', end='')

            # if len([None for tr in trlist if tr.direc[1]]) % 2:
            #     in_not_out ^= True

            in_not_out = (in_not_out or is_enter) and not is_exit

            # if tiledata[0] == '#' and past_char == '.':
            #     in_not_out ^= True

            # past_char = tiledata[0]


        #print()

    return volcount


print_map()
print(find_volume())
print('max = ', max_point, 'min = ', min_point)
