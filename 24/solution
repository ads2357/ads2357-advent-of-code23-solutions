#!/usr/bin/env python3

import itertools
import numpy as np

infilename = 'sample-input'
infilename = 'input'
#bound_min = np.array([7,7])
#bound_max = np.array([27,27])

bound_min = np.array([200000000000000,200000000000000])
bound_max = np.array([400000000000000,400000000000000])

with open(infilename, 'r') as f:
    inlines = f.readlines()

stones = []

for line in inlines:
    if not line.strip():
        break
    s_str, v_str = line.split('@')
    s, v = ( [ int(s) for s in sv_str.split(',') ] for sv_str in line.split('@') )

    stones.append((np.array(s[:2]),np.array(v[:2])))

# list for debugging sample input, don't care about memory.
pairs = list(itertools.combinations(enumerate(stones),2))

def is_parallel(v0, v1):
    return all(np.cross(v0, v1) == np.zeros_like(v0))

crossings = []

ii=0

import sys

print('greet')

# TODO: remove jank and mystery negations

# keep it simple: check whether each pair crosses in the future.
for (i0, (s0, v0)), (i1, (s1, v1)) in pairs:
    #sys.stderr.write('{}\r'.format(ii))
    ii += 1
    #sys.stderr.flush()

    # parallel - no cross
    if is_parallel(v0, v1):
        #print(s0, v0, ',', s1, v1, ' parallel')
        continue

    # close the initial distance using the velocities:
    # v0 . t + v1 . t = s1 - s0
    # i.e. V.t = d, a linear system.
    ds = s0 - s1
    coeff = np.array([v0, v1]).T

    times = np.linalg.solve(coeff, ds)

    # recover intercepts for bounds check
    int0 = s0 + times[0] * v0
    int1 = s1 + times[1] * v1

    if not (times[0] <= 0 and times[1] >= 0):
        #print(s0, v0, ',', s1, v1, 'past')
        continue

    if (int1 < bound_min).any() or (int1 > bound_max).any():
        #print(s0, v0, ',', s1, v1, 'bounds')
        continue

    crossings.append((int0, int1))

print(len(crossings), '/', len(pairs))

## Part 2

### Idea: conn line between stones, intercept to other stone.

s0, v0 = stones[0]
s1, v1 = [(s,v) for s,v in stones if not is_parallel(v, v0)][0]
s2, v2 = [(s,v) for s,v in stones if not is_parallel(v, v0) and not is_parallel(v,v1)][0] # perf opt

# conn: a + kb
# t=0:  s0 + k(s1-s0)
# t=t:  s0+t.v0 + k(s1+t.v1 - s0 - t.v0)

# conn(t,k) = stone[2](t)
# conn(t,k) - stone[2](t) = 0

# A non-linear problem because t and k are multiplied together. (Makes sense!)

# k.t is annoying, but could multiply the y member of the system of
# equations to make the k.t coeff the same, then subtract one from the
# other to get rid of k.t. Leaves us with a two-variable linear
# equation to solve, but we only have one equation left.

# We could try to do the same with all other triplets of stones. Each
# one would create a new 'k' and 't'. However, they could be pulled
# together because all the solutions have to lie in a straight line.

# Or try pulling in just one more stone? Acting like the third stone
# we already introduced? Produces two more variables, t3 and k3. But
# now we can create more connections between pairs of stones
# intercepting third stones. The 't's will be shared.



# On the other hand, could simply use:
## s_rock + t_rock_and_stone . v_rock = s_stone + t_rock_and_stone . v_stone, for all stones.
## Sum over all stones to produce a vector/matrix equation, with unknown t and unknown s_rock, v_rock.
## Solve numerically. (Probably slow because such a multidimensional space: 300 dimensions, wide range.)

def func(times_and_sr_and_vr, stones, n):
    times = times_and_sr_and_vr[n]
    
